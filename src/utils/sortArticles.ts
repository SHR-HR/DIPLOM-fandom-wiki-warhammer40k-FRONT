// J:\MAIN_DIP-М\FRONT\src\utils\sortArticles.ts

/**
 * УТИЛИТЫ СОРТИРОВКИ СТАТЕЙ ДЛЯ WARHAMMER 40,000 FANDOM WIKI
 * 
 * Этот файл содержит функции и типы для сортировки статей вики
 * по различным критериям с учетом особенностей данных
 */

/** 
 * ТИПЫ КЛЮЧЕЙ СОРТИРОВКИ ДЛЯ КЛИЕНТСКОЙ ЧАСТИ
 * 
 * Определяет все возможные варианты сортировки статей:
 * - По ID: возрастание/убывание
 * - По дате: новые/старые сначала  
 * - По заголовку: алфавит A-Z/Z-A
 * - По автору: алфавит A-Z
 */
export type SortKey =
  | "id_asc" | "id_desc"           // Сортировка по ID (возрастание/убывание)
  | "newest" | "oldest"            // Сортировка по дате создания (новые/старые)
  | "title_asc" | "title_desc"     // Сортировка по заголовку (A-Z/Z-A)
  | "author_asc";                  // Сортировка по автору (A-Z)

/**
 * МИНИМАЛЬНЫЙ ИНТЕРФЕЙС СТАТЬИ ДЛЯ СОРТИРОВКИ
 * 
 * Соответствует структуре articles.json
 * Все поля опциональны для обработки неполных данных
 */
export type Article = {
  id?: number | string;           // Уникальный идентификатор (число или строка)
  title?: string;                 // Заголовок статьи
  author?: string;               // Имя автора
  createdAt?: string;            // Дата создания в ISO формате (или другом, парсимом Date)
};

/**
 * ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ БЕЗОПАСНОГО ПРЕОБРАЗОВАНИЯ ДАННЫХ
 */

/**
 * Безопасно преобразует любое значение в число
 * Возвращает NaN если преобразование невозможно
 * 
 * @param x - любое значение для преобразования
 * @returns число или NaN
 */
const toNum = (x: unknown) => {
  const n = Number(x);
  return Number.isFinite(n) ? n : NaN; // Проверяем на конечное число (не Infinity/NaN)
};

/**
 * Безопасно извлекает строку из любого значения
 * Возвращает пустую строку для нестроковых значений
 * 
 * @param s - значение для проверки
 * @returns строку или пустую строку
 */
const safeStr = (s: unknown) => (typeof s === "string" ? s : "");

/**
 * КОЛЛЕКЦИЯ КОМПАРАТОРОВ ДЛЯ РАЗЛИЧНЫХ ТИПОВ СОРТИРОВКИ
 * 
 * Каждый компаратор реализует:
 * - Основную логику сортировки по указанному полю
 * - Стабильные тай-брейкеры для одинаковых значений
 * - Обработку отсутствующих или некорректных данных
 * - Локализованное сравнение для русского языка
 */
const comparators: Record<SortKey, (a: Article, b: Article) => number> = {
  /** 
   * СОРТИРОВКА ПО ID ПО ВОЗРАСТАНИЮ
   * - Сначала сравниваем числовые ID
   * - Элементы без ID помещаются в конец
   * - При одинаковых ID сортируем по заголовку
   */
  id_asc: (a, b) => {
    const A = toNum(a.id); 
    const B = toNum(b.id);
    
    // Оба ID невалидны - сортируем по заголовку
    if (Number.isNaN(A) && Number.isNaN(B)) 
      return safeStr(a.title).localeCompare(safeStr(b.title), "ru");
    
    // Элементы без ID всегда в конце при сортировке по возрастанию
    if (Number.isNaN(A)) return 1;   // a без ID -> a больше b
    if (Number.isNaN(B)) return -1;  // b без ID -> a меньше b
    
    // Основное сравнение числовых ID
    const diff = A - B;
    
    // Тай-брейкер по заголовку при одинаковых ID
    return diff || safeStr(a.title).localeCompare(safeStr(b.title), "ru");
  },

  /** 
   * СОРТИРОВКА ПО ID ПО УБЫВАНИЮ  
   * - Обратная логика id_asc
   * - Элементы без ID помещаются в начало
   */
  id_desc: (a, b) => {
    const A = toNum(a.id); 
    const B = toNum(b.id);
    
    if (Number.isNaN(A) && Number.isNaN(B)) 
      return safeStr(a.title).localeCompare(safeStr(b.title), "ru");
    
    if (Number.isNaN(A)) return 1;   // a без ID -> a больше b (в убывающей сортировке это ближе к началу)
    if (Number.isNaN(B)) return -1;  // b без ID -> a меньше b
    
    const diff = B - A;  // Обратное сравнение для убывания
    
    return diff || safeStr(a.title).localeCompare(safeStr(b.title), "ru");
  },

  /** 
   * СНАЧАЛА НОВЫЕ СТАТЬИ
   * - Сравниваем даты создания (более новые сначала)
   * - Тай-брейкер: более высокий ID сначала (предполагаем что новые статьи имеют большие ID)
   */
  newest: (a, b) => {
    // Преобразуем даты в timestamp и вычитаем (новые даты будут иметь больший timestamp)
    const diff = +new Date(safeStr(b.createdAt)) - +new Date(safeStr(a.createdAt));
    
    // При одинаковых датах - статьи с большим ID сначала
    return diff || toNum(b.id) - toNum(a.id);
  },

  /** 
   * СНАЧАЛА СТАРЫЕ СТАТЬИ  
   * - Обратная логика newest
   * - Тай-брейкер: более низкий ID сначала
   */
  oldest: (a, b) => {
    // Старые даты имеют меньший timestamp - они будут первыми
    const diff = +new Date(safeStr(a.createdAt)) - +new Date(safeStr(b.createdAt));
    
    // При одинаковых датах - статьи с меньшим ID сначала
    return diff || toNum(a.id) - toNum(b.id);
  },

  /** 
   * СОРТИРОВКА ПО ЗАГОЛОВКУ A-Z
   * - Локализованное сравнение для русского языка
   * - Учитывает регистр и специальные символы
   */
  title_asc: (a, b) => 
    safeStr(a.title).localeCompare(safeStr(b.title), "ru"),

  /** 
   * СОРТИРОВКА ПО ЗАГОЛОВКУ Z-A  
   * - Обратное сравнение title_asc
   */
  title_desc: (a, b) => 
    safeStr(b.title).localeCompare(safeStr(a.title), "ru"),

  /** 
   * СОРТИРОВКА ПО АВТОРУ A-Z
   * - Локализованное сравнение имен авторов
   * - Без тай-брейкера (сохраняет исходный порядок при одинаковых авторах)
   */
  author_asc: (a, b) => 
    safeStr(a.author).localeCompare(safeStr(b.author), "ru"),
};

/**
 * ОСНОВНАЯ ФУНКЦИЯ СОРТИРОВКИ СТАТЕЙ
 * 
 * Сортирует массив статей по указанному ключу без мутации исходного массива
 * 
 * @param articles - массив статей для сортировки
 * @param key - ключ сортировки из типа SortKey
 * @returns новый отсортированный массив
 * 
 * @template T - тип статьи, расширяющий базовый интерфейс Article
 */
export function sortArticles<T extends Article>(articles: T[], key: SortKey): T[] {
  // Получаем соответствующий компаратор для ключа сортировки
  const cmp = comparators[key];
  
  // Создаем копию массива через spread оператор для избежания мутации исходных данных
  // Array.prototype.sort мутирует массив, поэтому важно работать с копией
  return [...articles].sort(cmp);
}

// ===== АРХИТЕКТУРНЫЕ ОСОБЕННОСТИ МОДУЛЯ СОРТИРОВКИ =====

/**
 * КЛЮЧЕВЫЕ ПРИНЦИПЫ РЕАЛИЗАЦИИ:
 * 
 * 1. НЕМУТИРУЮЩАЯ СОРТИРОВКА:
 *    - Всегда возвращается новый массив
 *    - Исходные данные остаются неизменными
 *    - Важно для React и иммутабельных состояний
 * 
 * 2. СТАБИЛЬНОСТЬ СОРТИРОВКИ:
 *    - Тай-брейкеры обеспечивают предсказуемый порядок
 *    - Одинаковые элементы сохраняют относительный порядок
 *    - Локализованное сравнение для русского языка
 * 
 * 3. ОБРАБОТКА ГРАНИЧНЫХ СЛУЧАЕВ:
 *    - Отсутствующие поля (undefined, null)
 *    - Некорректные типы данных
 *    - Невалидные даты и числа
 * 
 * 4. ПРОИЗВОДИТЕЛЬНОСТЬ:
 *    - Предварительно скомпилированные компараторы
 *    - Минимальное количество преобразований
 *    - Эффективные операции сравнения
 */

/**
 * ОСОБЕННОСТИ ДЛЯ WARHAMMER 40,000 FANDOM WIKI:
 * 
 * - Поддержка сложных идентификаторов (числа и строки)
 * - Локализация для русскоязычного контента
 * - Обработка статей с неполными метаданными
 * - Сохранение исторического порядка через ID
 */

/**
 * ВАЖНЫЕ МОМЕНТЫ ДЛЯ РАЗРАБОТЧИКОВ:
 * 
 * - Все компараторы должны возвращать число (отрицательное, 0, положительное)
 * - localeCompare с указанием локали 'ru' правильно обрабатывает русскую азбуку
 * - Spread оператор [...] создает shallow copy (поверхностную копию)
 * - toNum и safeStr защищают от исключений при некорректных данных
 * 
 * При добавлении новых типов сортировки необходимо:
 * 1. Расширить тип SortKey
 * 2. Добавить компаратор в объект comparators
 * 3. Протестировать с различными наборами данных
 */

// Модуль обеспечивает надежную и производительную сортировку
// для системы управления контентом Warhammer 40,000 вики


// Основные особенности комментирования:

// 1. Детальное описание логики сортировки

// Объяснение работы каждого компаратора
// Логика тай-брейкеров для одинаковых значений
// Особенности обработки граничных случаев


// 2. Технические нюансы

// Принципы немутрирующей сортировки
// Работа с локализацией (русский язык)
// Безопасное преобразование типов


// 3. Архитектурные решения

// Структура данных для статей
// Выбор подхода с предопределенными компараторами
// Обоснование использования Spread оператора


// 4. Контекст Warhammer 40,000

// Учет особенностей идентификаторов в вселенной
// Поддержка исторического порядка через ID
// Обработка неполных метаданных статей

// Теперь логика сортировки полностью понятна и документирована для разработчиков!




