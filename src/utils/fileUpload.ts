// J:\MAIN_DIP-М\FRONT\src\utils\fileUpload.ts

/**
 * СИСТЕМА ЗАГРУЗКИ И ВАЛИДАЦИИ ФАЙЛОВ ДЛЯ WARHAMMER 40,000 FANDOM WIKI
 * 
 * Этот модуль обеспечивает клиентскую валидацию и подготовку изображений
 * перед загрузкой на сервер, включая проверки размера, типа и создание превью
 */

/** 
 * ОГРАНИЧЕНИЯ И ПАРАМЕТРЫ ДЛЯ ЗАГРУЗКИ ИЗОБРАЖЕНИЙ
 * 
 * Максимальный размер файла: 5 МБ
 * Соответствует типичным ограничениям для веб-приложений
 */
export const MAX_IMAGE_SIZE = 5 * 1024 * 1024; // 5 МБ в байтах

/**
 * РАЗРЕШЕННЫЕ MIME-ТИПЫ ИЗОБРАЖЕНИЙ
 * 
 * Поддерживаемые форматы:
 * - PNG: для изображений с прозрачностью
 * - JPEG/JPG: для фотографий и сложных изображений
 * - WEBP: современный формат с хорошим сжатием
 * - GIF: для анимированных изображений
 */
export const ALLOWED_TYPES = ["image/png", "image/jpeg", "image/jpg", "image/webp", "image/gif"];

/**
 * РЕГУЛЯРНОЕ ВЫРАЖЕНИЕ ДЛЯ ПРОВЕРКИ РАСШИРЕНИЙ ФАЙЛОВ
 * 
 * Дублирует проверку MIME-типов на уровне имен файлов
 * Используется как fallback когда file.type недоступен
 */
const ALLOWED_EXT_RE = /\.(png|jpe?g|webp|gif)$/i;

/**
 * ОПРЕДЕЛЕНИЕ MIME-ТИПА ПО ИМЕНИ ФАЙЛА
 * 
 * Используется как fallback когда браузер не может определить file.type
 * Часто возникает при перетаскивании файлов или в некоторых браузерах
 * 
 * @param name - имя файла для анализа
 * @returns string | null - MIME-тип или null если не удалось определить
 */
function detectTypeByName(name: string): string | null {
  // Проверяем расширение файла с помощью регулярного выражения
  if (ALLOWED_EXT_RE.test(name)) {
    const ext = name.split(".").pop()?.toLowerCase();
    if (!ext) return null;
    
    // Специальная обработка для JPEG (несколько вариантов расширения)
    if (ext === "jpg" || ext === "jpeg") return "image/jpeg";
    
    // Для остальных форматов создаем MIME-тип по шаблону
    return `image/${ext}`;
  }
  return null;
}

/**
 * ВАЛИДАЦИЯ ФАЙЛА ИЗОБРАЖЕНИЯ
 * 
 * Выполняет комплексную проверку файла перед загрузкой:
 * - Наличие файла
 * - Размер файла
 * - MIME-тип и расширение
 * 
 * @param file - объект File для валидации
 * @returns string | null - текст ошибки или null если валидация пройдена
 */
export function validateImageFile(file: File): string | null {
  // Проверка наличия файла
  if (!file) return "Файл не выбран";
  
  // Проверка размера файла
  if (file.size > MAX_IMAGE_SIZE) return "Файл слишком большой (максимум 5 MB)";

  // Определение MIME-типа с fallback на анализ имени файла
  const type = file.type || detectTypeByName(file.name) || "";
  
  // Базовая проверка что это изображение
  if (!type.startsWith("image/")) return "Файл должен быть изображением";
  
  // Проверка что формат входит в список разрешенных
  if (!ALLOWED_TYPES.includes(type)) return "Допустимые форматы: PNG, JPEG, WEBP, GIF";

  // Файл прошел все проверки
  return null;
}

/**
 * СОЗДАНИЕ DATA:URL ПРЕВЬЮ ДЛЯ ИЗОБРАЖЕНИЯ
 * 
 * Читает файл и преобразует его в data:URL для мгновенного отображения
 * в интерфейсе до загрузки на сервер
 * 
 * @param file - файл изображения для создания превью
 * @returns Promise<string> - Promise с data:URL превью
 * @throws Error - если файл не прошел валидацию или произошла ошибка чтения
 */
export function createFilePreview(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    // Предварительная валидация файла
    const err = validateImageFile(file);
    if (err) {
      reject(new Error(err));
      return;
    }

    // Используем FileReader для чтения файла как data:URL
    const reader = new FileReader();
    
    // Обработчик успешного чтения
    reader.onload = (e) => {
      const result = e.target?.result;
      
      // Проверяем что результат - валидный data:URL
      if (typeof result === "string" && result.startsWith("data:")) {
        resolve(result);
      } else {
        reject(new Error("Не удалось прочитать файл"));
      }
    };
    
    // Обработчик ошибок чтения
    reader.onerror = () => reject(new Error("Ошибка чтения файла"));
    
    // Запускаем чтение файла как data:URL
    reader.readAsDataURL(file);
  });
}

/**
 * СОЗДАНИЕ FORMDATA ДЛЯ ОТПРАВКИ ФАЙЛА НА СЕРВЕР
 * 
 * Подготавливает FormData для multipart/form-data запроса
 * Автоматически выполняет валидацию перед созданием
 * 
 * @param file - файл для отправки
 * @param field - имя поля формы (по умолчанию "file")
 * @returns FormData - подготовленный объект FormData
 * @throws Error - если файл не прошел валидацию
 */
export function buildImageForm(file: File, field: string = "file"): FormData {
  // Валидация файла перед созданием FormData
  const err = validateImageFile(file);
  if (err) throw new Error(err);
  
  // Создаем новый объект FormData
  const fd = new FormData();
  
  // Добавляем файл в FormData с указанным именем поля
  fd.append(field, file, file.name);
  
  return fd;
}

// ===== АРХИТЕКТУРНЫЕ ОСОБЕННОСТИ СИСТЕМЫ ЗАГРУЗКИ ФАЙЛОВ =====

/**
 * КЛЮЧЕВЫЕ ПРИНЦИПЫ РЕАЛИЗАЦИИ:
 * 
 * 1. МНОГОУРОВНЕВАЯ ВАЛИДАЦИЯ:
 *    - Проверка размера файла (MAX_IMAGE_SIZE)
 *    - Проверка MIME-типа (ALLOWED_TYPES)
 *    - Fallback проверка по расширению (detectTypeByName)
 *    - Предварительная валидация перед созданием превью
 * 
 * 2. ПОЛЬЗОВАТЕЛЬСКИЙ ОПЫТ:
 *    - Мгновенное превью через data:URL
 *    - Четкие сообщения об ошибках на русском языке
 *    - Защита от загрузки некорректных файлов
 * 
 * 3. БЕЗОПАСНОСТЬ:
 *    - Проверка типа файла на клиенте экономит серверные ресурсы
 *    - Ограничение размера предотвращает DoS-атаки
 *    - Явное указание разрешенных форматов
 * 
 * 4. СОВМЕСТИМОСТЬ:
 *    - Поддержка различных сценариев загрузки (выбор, drag&drop)
 *    - Fallback для случаев когда file.type недоступен
 *    - Стандартный FormData для совместимости с бэкендом
 */

/**
 * ПОТОК ДАННЫХ ПРИ ЗАГРУЗКЕ ИЗОБРАЖЕНИЯ:
 * 
 * 1. ПОЛЬЗОВАТЕЛЬ ВЫБИРАЕТ ФАЙЛ
 *    → input[type="file"] или drag&drop
 * 
 * 2. КЛИЕНТСКАЯ ВАЛИДАЦИЯ
 *    → validateImageFile() проверяет размер и тип
 *    → Показ ошибки или продолжение процесса
 * 
 * 3. СОЗДАНИЕ ПРЕВЬЮ (ОПЦИОНАЛЬНО)
 *    → createFilePreview() создает data:URL
 *    → Мгновенное отображение в интерфейсе
 * 
 * 4. ПОДГОТОВКА К ОТПРАВКЕ
 *    → buildImageForm() создает FormData
 *    → Отправка на сервер через fetch/axios
 * 
 * 5. СЕРВЕРНАЯ ВАЛИДАЦИЯ
 *    → Дополнительные проверки на бэкенде
 *    → Сохранение файла и возврат URL
 */

/**
 * ОСОБЕННОСТИ ДЛЯ WARHAMMER 40,000 FANDOM WIKI:
 * 
 * - Поддержка форматов оптимальных для скриншотов игр и артов
 * - Баланс между качеством и размером для обилия медиа-контента
 * - Учет что пользователи могут загружать фанарт и скриншоты из разных источников
 */

/**
 * ВАЖНЫЕ МОМЕНТЫ ДЛЯ РАЗРАБОТЧИКОВ:
 * 
 * - MAX_IMAGE_SIZE указан в байтах для точности
 * - ALLOWED_TYPES дублируется регулярным выражением для надежности
 * - detectTypeByName это fallback, а не основная проверка
 * - createFilePreview автоматически валидирует файл перед созданием превью
 * - FormData использует оригинальное имя файла для совместимости
 * 
 * При расширении функциональности необходимо:
 * 1. Обновить ALLOWED_TYPES и ALLOWED_EXT_RE синхронно
 * 2. Рассмотреть добавление проверки размеров изображения
 * 3. Учесть возможность загрузки анимированных WebP
 */

// Модуль обеспечивает надежную клиентскую подготовку
// медиа-файлов для богатого контента Warhammer 40,000 вики


// Основные особенности комментирования:

// 1. Детальное описание валидации

// Многоуровневая система проверок
// Fallback механизмы для разных браузеров
// Четкая логика обработки ошибок

// 2. Архитектура работы с файлами

// Преобразование в data:URL для превью
// Подготовка FormData для отправки
// Асинхронная обработка через Promise

// 3. Безопасность и производительность

// Защита от больших файлов
// Предварительная валидация на клиенте
// Оптимальные форматы для веб-использования

// 4. Контекст Warhammer 40,000

// Учет особенностей игровых скриншотов и артов
// Баланс качества и размера для медиа-контента
// Поддержка разнообразных источников изображений

// Теперь система загрузки файлов полностью документирована и понятна для разработчиков!


