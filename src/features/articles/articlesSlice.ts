import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import * as api from "@/api/endpoints";
import type { ApiArticle, ApiArticleShort } from "@/models/api";

/**
 * ASYNC THUNK ДЛЯ ЗАГРУЗКИ СПИСКА СТАТЕЙ С СЕРВЕРНОЙ ОБРАБОТКОЙ
 * 
 * Выполняет загрузку пагинированного списка статей с поддержкой:
 * - Поиска по заголовку (параметр q)
 * - Сортировки по различным полям (id, title, author)
 * - Направления сортировки (asc, desc)
 * - Пагинации (start, limit)
 * 
 * @param start - смещение для пагинации (сколько элементов пропустить)
 * @param limit - количество элементов на странице
 * @param q - поисковый запрос (опционально)
 * @param sort - поле для сортировки (опционально)
 * @param dir - направление сортировки (опционально)
 * @returns объект с элементами списка, общим количеством и поисковым запросом
 */
export const fetchList = createAsyncThunk<
  { items: ApiArticleShort[]; total: number; q: string },
  {
    start: number;
    limit: number;
    q?: string;
    sort?: "id" | "title" | "author";
    dir?: "asc" | "desc";
  }
>(
  "articles/fetchList",
  async ({ start, limit, q, sort, dir }) => {
    const { items, total } = await api.getArticles(start, limit, q, sort, dir);
    return { items, total, q: q || "" };
  }
);

/**
 * ASYNC THUNK ДЛЯ ЗАГРУЗКИ КОНКРЕТНОЙ СТАТЬИ ПО ID
 * 
 * Загружает полные данные статьи по её идентификатору.
 * Используется для страницы просмотра отдельной статьи.
 * 
 * @param id - уникальный идентификатор статьи
 * @returns полный объект статьи
 */
export const fetchById = createAsyncThunk("articles/fetchById", async (id: number) => {
  const art = await api.getArticle(id);
  return art;
});

/**
 * ТИП СОСТОЯНИЯ ДЛЯ УПРАВЛЕНИЯ СТАТЬЯМИ
 * 
 * Структура хранит как список статей для отображения, так и отдельные статьи
 * для избежания повторных загрузок (кеширование по ID):
 * - list: массив кратких описаний статей для списков
 * - total: общее количество статей (для пагинации)
 * - loading: флаг загрузки данных
 * - error: сообщение об ошибке
 * - byId: кеш полных статей, индексированный по ID
 * - lastQuery: последний выполненный поисковый запрос
 */
type State = {
  list: ApiArticleShort[];
  total: number;
  loading: boolean;
  error?: string | null;
  byId: Record<number, ApiArticle>;
  lastQuery: string;
};

/**
 * НАЧАЛЬНОЕ СОСТОЯНИЕ СТАТЕЙ
 * 
 * Инициализирует состояние с пустыми значениями:
 * - list: [] - пустой список статей
 * - total: 0 - нулевое общее количество
 * - loading: false - отсутствие активной загрузки
 * - error: null - отсутствие ошибок
 * - byId: {} - пустой кеш статей
 * - lastQuery: "" - пустой поисковый запрос
 */
const initial: State = {
  list: [],
  total: 0,
  loading: false,
  error: null,
  byId: {},
  lastQuery: "",
};

/**
 * SLICE ДЛЯ УПРАВЛЕНИЯ СОСТОЯНИЕМ СТАТЕЙ WARHAMMER 40,000 FANDOM WIKI
 * 
 * Обрабатывает все операции, связанные со статьями:
 * - Загрузка списка статей с фильтрацией и сортировкой
 * - Загрузка отдельных статей по идентификатору
 * - Управление состоянием загрузки и ошибками
 * - Кеширование загруженных статей для оптимизации
 */
const slice = createSlice({
  name: "articles",
  initialState: initial,
  reducers: {},
  extraReducers: (b) => {
    /**
     * ОБРАБОТЧИКИ ДЛЯ fetchList (ЗАГРУЗКА СПИСКА СТАТЕЙ)
     */
    
    // ЗАПРОС В ПРОЦЕССЕ - УСТАНАВЛИВАЕМ ФЛАГ ЗАГРУЗКИ
    b.addCase(fetchList.pending, (s) => {
      s.loading = true;
      s.error = null;
    });
    
    // УСПЕШНАЯ ЗАГРУЗКА - СОХРАНЯЕМ ДАННЫЕ И ПОИСКОВЫЙ ЗАПРОС
    b.addCase(fetchList.fulfilled, (s, a) => {
      s.loading = false;
      s.list = a.payload.items;
      s.total = a.payload.total;
      s.lastQuery = a.payload.q;
    });
    
    // ОШИБКА ЗАГРУЗКИ - СОХРАНЯЕМ СООБЩЕНИЕ ОБ ОШИБКЕ
    b.addCase(fetchList.rejected, (s, a) => {
      s.loading = false;
      s.error = String(a.error.message || "Ошибка загрузки списка");
    });

    /**
     * ОБРАБОТЧИКИ ДЛЯ fetchById (ЗАГРУЗКА КОНКРЕТНОЙ СТАТЬИ)
     */
    
    // УСПЕШНАЯ ЗАГРУЗКА - ДОБАВЛЯЕМ СТАТЬЮ В КЕШ ПО ID
    b.addCase(fetchById.fulfilled, (s, a) => {
      s.byId[a.payload.id] = a.payload;
    });
    
    // ОШИБКА ЗАГРУЗКИ - СОХРАНЯЕМ СООБЩЕНИЕ ОБ ОШИБКЕ
    b.addCase(fetchById.rejected, (s, a) => {
      s.error = String(a.error.message || "Ошибка загрузки статьи");
    });
  },
});

export default slice.reducer;





// Комментарии объясняют:

// 1. Архитектуру управления состоянием статей

// Разделение ответственности между списком и отдельными статьями
// Серверную обработку фильтрации, сортировки и пагинации
// Кеширование данных для оптимизации производительности

// 2. Систему async thunk операций

// fetchList - загрузка списка с поддержкой поиска и сортировки
// fetchById - загрузка конкретной статьи для страницы просмотра
// Типизированные параметры для всех операций

// 3. Структуру состояния и кеширования

// Двойное хранение - список для отображения и кеш по ID
// Отслеживание последнего запроса для согласованного UI
// Раздельное управление состоянием загрузки и ошибками

// 4. Бизнес-логику работы со статьями

// Интеграцию с API endpoints для всех операций
// Поддержку пагинации через параметры start и limit
// Поиск и сортировку на серверной стороне для производительности

// 5. Обработку состояний и ошибок

// Управление флагом loading для отображения индикаторов
// Централизованную обработку ошибок с понятными сообщениями
// Сброс ошибок при начале новых операций

// Этот слайс обеспечивает надежное управление 
// состоянием статей в Warhammer 40,000 Fandom Wiki, поддерживая все необходимые
// операции для работы со статьями - от отображения списков до просмотра отдельных
// материалов, с оптимизацией производительности через кеширование 
// и эффективную обработку состояний.





